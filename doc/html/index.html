<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Boost.Nowide: Boost.Nowide</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Nowide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Boost.Nowide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Table of Contents:</p>
<ul>
<li><a class="el" href="index.html#main">What is Boost.Nowide</a></li>
<li><a class="el" href="index.html#main_rationale">Rationale</a><ul>
<li><a class="el" href="index.html#main_the_problem">The Problem</a></li>
<li><a class="el" href="index.html#main_the_solution">The Solution</a></li>
<li><a class="el" href="index.html#main_wide">Why Not Narrow and Wide?</a></li>
<li><a class="el" href="index.html#main_reading">Further Reading</a></li>
</ul>
</li>
<li><a class="el" href="index.html#using">Using The Library</a><ul>
<li><a class="el" href="index.html#using_standard">Standard Features</a></li>
<li><a class="el" href="index.html#using_custom">Custom API</a></li>
</ul>
</li>
<li><a class="el" href="index.html#technical">Technical Details</a><ul>
<li><a class="el" href="index.html#technical_imple">Windows vs POSIX</a></li>
<li><a class="el" href="index.html#technical_cio">Console I/O</a></li>
</ul>
</li>
<li><a class="el" href="index.html#qna">Q &amp; A</a></li>
</ul>
<h2><a class="anchor" id="main"></a>
What is Boost.Nowide</h2>
<p>Boost.Nowide is a library implemented by Artyom Beilis that make cross platform Unicode aware programming easier.</p>
<p>The library provides an implementation of standard C and C++ library functions, such that their inputs are UTF-8 aware on Windows without requiring to use Wide API.</p>
<h2><a class="anchor" id="main_rationale"></a>
Rationale</h2>
<h3><a class="anchor" id="main_the_problem"></a>
The Problem</h3>
<p>Consider a simple application that splits a big file into chunks, such that they can be sent by e-mail. It requires doing few very simple taks:</p>
<ul>
<li>Access command line arguments: <code>int main(int argc,char **argv)</code></li>
<li>Open a input file, open several output files: <code>std::fstream::open(char const *,std::ios::openmode m)</code></li>
<li>Remove the files in case of fault: <code>std::remove(char const *file)</code></li>
<li>Print a progress report into console: <code>std::cout &lt;&lt; file_name </code></li>
</ul>
<p>Unfortunately it is impossible to implement this simple task in a plain C++ if the file names contain non-ASCII characters</p>
<p>The simple program that uses the API would work on the systems that use UTF-8 internally -- the vast majority of Unix-Line operating systems: Linux, Mac OS X, Solaris, BSD. But it would fail on files like <code>War and Peace - Война и мир - מלחמה ושלום.zip</code> under Microsoft Windows because the native Windows Unicode aware API is Wide-API - UTF-16.</p>
<p>This, such a trivial task is very hard to implement in a cross platform manner.</p>
<h3><a class="anchor" id="main_the_solution"></a>
The Solution</h3>
<p>Boost.Nowide provides a set of standard library functions that are UTF-8 aware and makes Unicode aware programming easier.</p>
<p>The library provides:</p>
<ul>
<li>Easy to use functions for converting UTF-8 to/from UTF-16</li>
<li>A class to fixing <code>argc</code>, <code>argc</code> and <code>env</code> <code>main</code> parameters to use UTF-8</li>
<li>UTF-8 aware functions<ul>
<li><code>stdio.h</code> functions:<ul>
<li><code>fopen</code> </li>
<li><code>freopen</code> </li>
<li><code>remove</code> </li>
<li><code>rename</code> </li>
</ul>
</li>
<li><code>stdlib.h</code> functions<ul>
<li><code>system</code> </li>
<li><code>getenv</code> </li>
<li><code>setenv</code> </li>
<li><code>unsetenv</code> </li>
<li><code>putenv</code> </li>
</ul>
</li>
<li><code>fstream</code> <ul>
<li><code>filebuf</code> </li>
<li><code>fstream/ofstream/ifstream</code> </li>
</ul>
</li>
<li><code>iostream</code> <ul>
<li><code>cout</code> </li>
<li><code>cerr</code> </li>
<li><code>clog</code> </li>
<li><code>cin</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="main_wide"></a>
Why Not Narrow and Wide?</h3>
<p>Why not to provide both Wide and Narrow implementations so the developer can choose to use Wide characters on Unix-Like platforms</p>
<p>Several reasons:</p>
<ul>
<li><code>wchar_t</code> is not really portable, it can be 2 bytes, 4 bytes or even 1 byte making Unicode aware programming harder</li>
<li>Standard C and C++ library uses narrow strings for OS interactions. This library follows this general rule. There is no such thing as <code>fopen(wchar_t const *,wchar_t const *)</code> in the standard library, so it is better to stick to the standards rather than re-implement Wide API in "Microsoft Windows Style"</li>
</ul>
<h3><a class="anchor" id="main_reading"></a>
Further Reading</h3>
<ul>
<li><a href="http://www.utf8everywhere.org/">www.utf8everywhere.org</a></li>
<li><a href="http://alfps.wordpress.com/2011/11/22/unicode-part-1-windows-console-io-approaches/">Windows console i/o approaches</a></li>
</ul>
<h2><a class="anchor" id="using"></a>
Using The Library</h2>
<h3><a class="anchor" id="using_standard"></a>
Standard Features</h3>
<p>The library is mostly header only library, only console I/O requires separate compilation under Windows.</p>
<p>As a developer you are expected to to <code><a class="el" href="namespaceboost_1_1nowide.html" title="This namespace includes implementation of the standard library functios such that they accept UTF-8 s...">boost::nowide</a></code> functions instead of the function avalible in the <code>std</code> namespace.</p>
<p>For example, Unicode unaware implementation of line counter: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span> **argv)
{
    <span class="keywordflow">if</span>(argc!=2) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: file_name&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1;
    }

    std::ifstream f(argv[1]);
    <span class="keywordflow">if</span>(!f) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open a file &quot;</span> &lt;&lt; argv[1] &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1;
    }
    <span class="keywordtype">int</span> total_lines = 0;
    <span class="keywordflow">while</span>(f) {
        <span class="keywordflow">if</span>(f.get() == <span class="charliteral">&#39;\n&#39;</span>)
            total_lines++;
    }
    f.close();
    std::cout &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; total_lines &lt;&lt; <span class="stringliteral">&quot; lines&quot;</span> &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>To make this program handle Unicode properly we do the following changes:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;boost/nowide/args.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/nowide/fstream.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/nowide/iostream.hpp&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span> **argv)
{
    <a class="code" href="classboost_1_1nowide_1_1args.html" title="args is a class that fixes standard main() function arguments and changes them to UTF-8 under Microso...">boost::nowide::args</a> a(argc,argv); <span class="comment">// Fix arguments - make them UTF-8</span>
    <span class="keywordflow">if</span>(argc!=2) {
        <a class="code" href="namespaceboost_1_1nowide.html#a1c43cbf142f4e42edb0fea6044d40bcb" title="Same as std::cerr, but uses UTF-8.">boost::nowide::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Usage: file_name&quot;</span> &lt;&lt; std::endl; <span class="comment">// Unicode aware console</span>
        <span class="keywordflow">return</span> 1;
    }

    <a class="code" href="classboost_1_1nowide_1_1basic__ifstream.html" title="Same as std::basic_ifstream&lt;char&gt; but accepts UTF-8 strings under Windows.">boost::nowide::ifstream</a> f(argv[1]); <span class="comment">// argv[1] - is UTF-8</span>
    <span class="keywordflow">if</span>(!f) {
        <span class="comment">// the console can display UTF-8</span>
        <a class="code" href="namespaceboost_1_1nowide.html#a1c43cbf142f4e42edb0fea6044d40bcb" title="Same as std::cerr, but uses UTF-8.">boost::nowide::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open a file &quot;</span> &lt;&lt; argv[1] &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1;
    }
    <span class="keywordtype">int</span> total_lines = 0;
    <span class="keywordflow">while</span>(f) {
        <span class="keywordflow">if</span>(f.get() == <span class="charliteral">&#39;\n&#39;</span>)
            total_lines++;
    }
    f.close();
    <span class="comment">// the console can display UTF-8</span>
    <a class="code" href="namespaceboost_1_1nowide.html#a3150e32a8082927f4843791c1dbc3587" title="Same as std::cout, but uses UTF-8.">boost::nowide::cout</a> &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; total_lines &lt;&lt; <span class="stringliteral">&quot; lines&quot;</span> &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>This is very simple and straight forward approach helps writing Unicode aware programs.</p>
<h3><a class="anchor" id="using_custom"></a>
Custom API</h3>
<p>Of course this simple set of functions does not cover all needs. However if you need to access Wide API from Windows application using UTF-8 encoding internally you can use functions like <code><a class="el" href="namespaceboost_1_1nowide.html#a6baacc1bb80c134a2ce37f13977b5500">boost::nowide::widen</a></code> and <code><a class="el" href="namespaceboost_1_1nowide.html#ac2b772caed760a75f611c2dc24153e4a">boost::nowide::narrow</a></code>.</p>
<p>For example </p>
<div class="fragment"><pre class="fragment">CopyFileW(  <a class="code" href="namespaceboost_1_1nowide.html#a6baacc1bb80c134a2ce37f13977b5500">boost::nowide::widen</a>(existing_file).c_str(),
            <a class="code" href="namespaceboost_1_1nowide.html#a6baacc1bb80c134a2ce37f13977b5500">boost::nowide::widen</a>(new_file).c_str(),
            TRUE);
</pre></div><p>So the conversion is done at the last stage and you continue using UTF-8 strings anywhere and only at glue points you switch to Wide API.</p>
<p><code><a class="el" href="namespaceboost_1_1nowide.html#a6baacc1bb80c134a2ce37f13977b5500">boost::nowide::widen</a></code> returns <code>std::string</code>. Sometimes it is convenient to prevent allocation and use on stack buffers if possible. Boot.Nowide provides <code><a class="el" href="classboost_1_1nowide_1_1basic__stackstring.html" title="A class that allows to create a temporary wide or narrow UTF strings from wide or narrow UTF source...">boost::nowide::basic_stackstring</a></code> class.</p>
<p>Such that the example above can be rewritten as:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classboost_1_1nowide_1_1basic__stackstring.html" title="A class that allows to create a temporary wide or narrow UTF strings from wide or narrow UTF source...">boost::nowide::basic_stackstring&lt;wchar_t,char,64&gt;</a> wexisting_file,wnew_file;
<span class="keywordflow">if</span>(!wexisting_file.convert(existing_file) || !wnew_file.convert(new_file)) {
    <span class="comment">// invalid UTF-8</span>
    <span class="keywordflow">return</span> -1;
}

CopyFileW(wexisting_file.c_str(),wnew_file.c_str(),TRUE);
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>There are convenience typedefs <code>stackstring</code>, <code>wstackstring</code>, <code>short_stackstring</code> and <code>wshort_stackstring</code> that use buffers of size 256 or 16 characters, and if the string is longer, they fall-back to memory allocation</dd></dl>
<h3><a class="anchor" id="using_windows_h"></a>
windows.h header</h3>
<p>The library does not include the <code>windows.h</code> in order to prevent namespace pollution with numerous defines and types. The library rather defines the prototypes to the Win32 API functions.</p>
<p>However if you may request to use original <code>windows.h</code> header by setting <code>BOOST_NOWIDE_USE_WINDOWS_H</code> define before including any of the Boost.Nowide headers</p>
<h2><a class="anchor" id="technical"></a>
Technical Details</h2>
<h3><a class="anchor" id="technical_imple"></a>
Windows vs POSIX</h3>
<p>The library provide UTF-8 aware functions for Microsoft Windows in <code><a class="el" href="namespaceboost_1_1nowide.html" title="This namespace includes implementation of the standard library functios such that they accept UTF-8 s...">boost::nowide</a></code> namespace that usually lay in <code>std:</code>: namespace, for example <code>std::fopen</code> goes to <code><a class="el" href="namespaceboost_1_1nowide.html#a45d432e5684010f865702af97d47f087" title="Same as fopen but file_name and mode are UTF-8 strings.">boost::nowide::fopen</a></code>.</p>
<p>Under POSIX platforms the <a class="el" href="namespaceboost_1_1nowide.html#a45d432e5684010f865702af97d47f087" title="Same as fopen but file_name and mode are UTF-8 strings.">boost::nowide::fopen</a> and all other functions are aliases to standard library functions:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>boost {
<span class="keyword">namespace </span>nowide {
<span class="preprocessor">#ifdef BOOST_WINDOWS</span>
<span class="preprocessor"></span><span class="keyword">inline</span> FILE *<a class="code" href="namespaceboost_1_1nowide.html#a45d432e5684010f865702af97d47f087" title="Same as fopen but file_name and mode are UTF-8 strings.">fopen</a>(<span class="keywordtype">char</span> <span class="keyword">const</span> *name,<span class="keywordtype">char</span> <span class="keyword">const</span> *mode)
{
    ...
}
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="keyword">using</span> std::fopen
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>} <span class="comment">// nowide</span>
} <span class="comment">// boost</span>
</pre></div><h3><a class="anchor" id="technical_cio"></a>
Console I/O</h3>
<p>Console I/O implemented as wrapper over ReadConsoleW/WriteConsoleW unless the stream is not "atty" like a pipe than ReadFile/WriteFile is used.</p>
<p>This approach eliminates a need of manual code page handling. If TrueType fonts are used the Unicode aware input and output would work.</p>
<h2><a class="anchor" id="qna"></a>
Q &amp; A</h2>
<p><b>Q: Why the library does not convert the string from Locale's encoding not UTF-8 and wise versa on POSIX systems</b></p>
<p>A: It is inherently incorrect to convert strings to/from locale encodings on POSIX platforms.</p>
<p>You can create a file named "\xFF\xFF.txt" (invalid UTF-8), remove it, pass its name as a parameter to program and it would work whether the current locale is UTF-8 locale or not. Also changing the locale from let's say <code>en_US.UTF-8</code> to <code>en_US.ISO-8859-1</code> would not magically change all files in OS or the strings a user may pass to the program (which is different on Windows)</p>
<p>POSIX OSs treat strings as <code>NUL</code> terminated cookies.</p>
<p>So altering their content according to the locale would actually lead to incorrect behavior.</p>
<p>For example, this is a naive implementation of a standard program "rm"</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;cstdio&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span> **argv)
{
   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;argc;i++)
     std::remove(argv[i]);
   <span class="keywordflow">return</span> 0;
}
</pre></div><p>It would work with ANY locale and changing the strings would lead to incorrect behavior.</p>
<p>The meaning of a locale under POSIX and Windows paltforms is different and has very different effects. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
